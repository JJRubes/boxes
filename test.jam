basic jam program with notes
has a stack and a queue
the stack is for 

everything is passed around



everything is thrown into a bin
when you pull out an item, it does something with it

a queue?
runs a first thing
which should push some items onto the queue
when an item is popped from the queue it has some amount of available
commands that can be run with this as input and enqueues a bunch
of stuff
what command will be run can be changed
so maybe an item has a class
then another item can modify the first items run function
so that would make it a meta item?
maybe something can create items to modify other items
and another item is an accumulator??
that takes 2 or more items off of the queue and enqueues a new item
from those

each type has an update function and 0, 1, or 2 child types, and a value
when an item reaches the top of the queue it is dequeued
the update function is run on it
which will push enqueue some new items
and/or change a child's update function.

TYPE:
  childtype, childtype
  updatefunction

update function?
add items
change update function
do nothing
add type?

add item needs to specify type, value(s) for each

does change update function cycle predefined functions?
or is it able to construct new functions?
it must be able to construct new functions if add type is a thing


entry item -> add number 1
              add number 0
              add number 0
              add number 1

number 1   -> add type reverser










graph
root node is given "focus"
then focus is given to each of it's children
do you construct the graph?
can the graph self-modify?
I think you construct at least the first graph



                        +---------------+
+---------------+       | rec char as c |
| rec char as c |       | add 1 to c    |
| print c       |<-----<| send c        |
+---------------+       +---------------+

+--------------------------+
| rec char from stdin as c |
| send c to out            |
+--------------------------+
            |
        out: char
            |
            v
    +---------------+
    | from out as c |
    | print c       |
    +---------------+



calculator

+-------------------- main ------------------------+
|                                                  |
|   +-+                                            |
|   |0|                                            |
|   +o+                                            |
|    |                                             |
|   +j-+   +-----------+                           |
| >-i[]o->-i parse int o-->-----v                  |
| | +--+   +-----------+        |                  |
| |                          +--x----+             |
| | +-----+   +----------+   |       |   +-------+ |
o-+-i [1] o->-> parse op o->-f apply o->-i print | |
| | +-----+   +----------+   |       |   +-------+ |
| |                          +--y----+             |
| | +-----+   +-----------+     |                  |
| >-i [2] o->-i parse int o-----^                  |
|   +-----+   +-----------+                        |
|                                                  |
+--------------------------------------------------+

+---------- parse op -----------+
|                               |
|      +---+ +---+ +---+ +---+  |
|      |'+'| |'-'| |'*'| |'/'|  |
|      +-o-+ +-o-+ +-o-+ +-o-+  |
|        |     |     |     |    |
|      +-x-----y-----z-----w-+  |
>-char-i case                o--o
|      +-a-----b-----c-----d-+  |
|        |     |     |     |    |
|      +-o-+ +-o-+ +-o-+ +-o-+  |
|      |+-+| |+-+| |+-+| |+-+|  |
|      |x+y| |x-y| |x*y| |x/y|  |
|      |+o+| |+o+| |+o+| |+o+|  |
|      +---+ +---+ +---+ +---+  |
|                               |
+-------------------------------+
